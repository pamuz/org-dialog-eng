* Customization Group
#+begin_src emacs-lisp
  ;;; Customization

  (defgroup org-dialog-eng nil
    "Claude AI integration for Org mode."
    :group 'org
    :prefix "org-dialog-eng-")

  (defcustom org-dialog-eng-command "claude"
    "Command to invoke Claude CLI."
    :type 'string
    :group 'org-dialog-eng)

  (defcustom org-dialog-eng-executable-path nil
    "Path to Claude CLI executable.
  If nil, the command will be searched in PATH."
    :type '(choice (const :tag "Use PATH" nil)
                   (file :tag "Executable path"))
    :group 'org-dialog-eng)

  (defface org-dialog-eng-prompt-block
    '((t (:background "#2d3a55" :extend t)))
    "Face for PROMPT block content."
    :group 'org-dialog-eng)

  (defface org-dialog-eng-assistant-block
    '((t (:background "#3d2f5b" :extend t)))
    "Face for ASSISTANT block content."
    :group 'org-dialog-eng)
#+end_src

* Utility Functions
#+begin_src emacs-lisp
  ;;; Utility Functions

  (defun org-dialog-eng--message (format-string &rest args)
    "Display a message for org-dialog-eng with FORMAT-STRING and ARGS."
    (message "[org-dialog-eng] %s" (apply #'format format-string args)))

  (defun org-dialog-eng--error (format-string &rest args)
    "Display an error message for org-dialog-eng with FORMAT-STRING and ARGS."
    (error "[org-dialog-eng] %s" (apply #'format format-string args)))
#+end_src

* Block Detection and Content Extraction
These functions detect PROMPT and RESPONSE blocks and extract their content.

#+begin_src emacs-lisp
  ;;; Block Detection and Content Extraction

#+end_src

* Context Building

These functions build the conversation context by parsing the org buffer.

** Element to Text Conversion
#+begin_src emacs-lisp
  (defun org-dialog-eng--element-to-text (element)
    "Convert an org ELEMENT to text for context building."
    (let ((type (org-element-type element)))
      (cond
       ;; Source code blocks - format as markdown
       ((eq type 'src-block)
        (let* ((lang (org-element-property :language element))
               (value (org-element-property :value element)))
          (format "```%s\n%s```" (or lang "") (string-trim value))))

       ;; PROMPT blocks - include content
       ((org-dialog-eng--element-is-prompt-block-p element)
        (org-dialog-eng--extract-block-content element))

       ;; ASSISTANT blocks - include content
       ((org-dialog-eng--element-is-response-block-p element)
        (org-dialog-eng--extract-block-content element))

       ;; Other elements - extract text
       (t
        (let* ((begin (org-element-property :begin element))
               (end (org-element-property :end element)))
          (when (and begin end)
            (string-trim
             (buffer-substring-no-properties begin end))))))))
#+end_src

** Context Builder
#+begin_src emacs-lisp
  ;;; Context Building

  (defun org-dialog-eng--build-context (end-pos)
    "Build context from buffer start to END-POS.
  Returns a string containing all relevant content before the prompt."
    (save-excursion
      (let* ((parse-tree (org-element-parse-buffer))
             (context-parts '()))

        ;; Collect all elements up to end-pos
        (org-element-map parse-tree '(headline paragraph src-block special-block plain-list)
          (lambda (element)
            (let ((elem-begin (org-element-property :begin element)))
              ;; Only process elements before END-POS
              (when (and elem-begin (< elem-begin end-pos))
                (when-let ((text (org-dialog-eng--element-to-text element)))
                  (unless (string-empty-p text)
                    (push text context-parts)))))))

        ;; Join all parts with double newlines
        (if context-parts
            (string-join (nreverse context-parts) "\n\n")
          ""))))
#+end_src

* Response Insertion

** ANSI Code Stripping
#+begin_src emacs-lisp
  ;;; Response Insertion

  (defun org-dialog-eng--strip-ansi-codes (text)
    "Remove ANSI escape codes and control characters from TEXT.
  Preserves newlines and tabs."
    ;; Remove CSI sequences (ESC[...letter)
    (setq text (replace-regexp-in-string "\033\\[[0-9;?]*[a-zA-Z]" "" text))
    ;; Remove other escape sequences
    (setq text (replace-regexp-in-string "\033[^[]" "" text))
    ;; Clean up control characters but preserve newline (\n = \x0A) and tab (\t = \x09)
    (setq text (replace-regexp-in-string "[\x00-\x08\x0B-\x1F\x7F]" "" text))
    text)
#+end_src

** Helper Functions for Blank Lines

These functions intelligently ensure blank lines exist without adding unnecessary newlines.

#+begin_src emacs-lisp
  (defun org-dialog-eng--ensure-blank-line-before ()
    "Ensure there is a blank line before point.
  Only inserts newlines if needed to create a blank line."
    (let ((chars-before (buffer-substring-no-properties
                         (max (point-min) (- (point) 2))
                         (point))))
      (cond
       ;; Already have blank line (two newlines before point)
       ((string-match-p "\n\n\\'" chars-before) nil)
       ;; Have one newline, need one more
       ((string-match-p "\n\\'" chars-before) (insert "\n"))
       ;; At start of buffer or no newlines, need two
       (t (insert "\n\n")))))

  (defun org-dialog-eng--ensure-blank-line-after ()
    "Ensure there is a blank line after point.
  Only inserts newlines if needed to create a blank line."
    (let ((chars-after (buffer-substring-no-properties
                        (point)
                        (min (point-max) (+ (point) 2)))))
      (cond
       ;; Already have blank line (two newlines after point)
       ((string-match-p "\\`\n\n" chars-after) nil)
       ;; Have one newline, need one more
       ((string-match-p "\\`\n" chars-after) (insert "\n"))
       ;; At end of buffer or no newlines, need two
       ((= (point) (point-max)) (insert "\n"))
       ;; Content immediately after, need two newlines
       (t (insert "\n\n")))))
#+end_src

** Response Block Insertion
#+begin_src emacs-lisp
  (defun org-dialog-eng--insert-response (response marker)
    "Insert RESPONSE as an ASSISTANT block at MARKER position."
    (when (and response (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          ;; Find the containing PROMPT block
          (let* ((element (org-element-at-point))
                 (block (org-element-lineage element '(special-block) t)))
            (when block
              ;; Go to the end of the PROMPT block
              (goto-char (org-element-property :end block))
              ;; Ensure blank line before assistant block
              (org-dialog-eng--ensure-blank-line-before)
              (insert "#+begin_assistant\n")
              (insert (string-trim (org-dialog-eng--strip-ansi-codes response)))
              (insert "\n#+end_assistant\n")
              ;; Ensure blank line after assistant block
              (org-dialog-eng--ensure-blank-line-after)
              (org-dialog-eng--message "Response inserted successfully")))))))
#+end_src

* Process Execution

** Process Filter
The process filter receives output from Claude as it arrives and accumulates
it in the process buffer.

#+begin_src emacs-lisp
  ;;; Process Execution

  (defun org-dialog-eng--process-filter (process output)
    "Process filter for Claude CLI PROCESS OUTPUT.
Accumulates output in process buffer."
    (when (buffer-live-p (process-buffer process))
      (with-current-buffer (process-buffer process)
        (goto-char (point-max))
        (insert output))))
#+end_src

** Process Sentinel
The sentinel handles process completion:
1. On success: inserts the response into the org buffer
2. On error: shows error message

#+begin_src emacs-lisp
  (defun org-dialog-eng--process-sentinel (process event)
    "Process sentinel for Claude CLI PROCESS.
  EVENT describes what happened to the process."
    (when-let ((buf (process-get process 'org-dialog-eng-buffer)))
      (when (buffer-live-p buf) (with-current-buffer buf (setq buffer-read-only nil))))
    (let ((status (process-status process))
  	(marker (process-get process 'org-dialog-eng-marker)))
      (cond
       ((eq status 'exit)
        (let ((exit-code (process-exit-status process)))
          (if (= exit-code 0)
              ;; Success - insert the response
              (when (buffer-live-p (process-buffer process))
                (let ((response (with-current-buffer (process-buffer process)
  				(buffer-string))))
                  (org-dialog-eng--insert-response response marker)
                  (kill-buffer (process-buffer process))))
            ;; Error - show message
            (org-dialog-eng--error "Claude CLI exited with code %d: %s"
  				 exit-code
  				 (if (buffer-live-p (process-buffer process))
                                       (with-current-buffer (process-buffer process)
                                         (buffer-string))
                                     "")))))

       ((eq status 'signal)
        (org-dialog-eng--error "Claude CLI process killed: %s" event))

       (t
        (org-dialog-eng--message "Claude CLI process status: %s" event)))))
#+end_src

** Execute Claude
This function starts the Claude process:
1. Starts the async process with the ~-p~ flag to pass the prompt
2. Wires up the filter and sentinel
3. Waits for Claude to respond

The process runs asynchronously, so Emacs remains responsive while Claude generates
the response.

#+begin_src emacs-lisp
  (defun org-dialog-eng--execute-claude (prompt-content marker)
    "Execute Claude with PROMPT-CONTENT asynchronously.
  Insert response at MARKER when complete."
    (let* ((executable (or org-dialog-eng-executable-path org-dialog-eng-command))
           (process-buffer (generate-new-buffer " *org-dialog-eng-output*"))
           (process-name "org-dialog-eng"))

      ;; Start the async process: claude -p "prompt content"
      (org-dialog-eng--message "Sending prompt to Claude...")
      (condition-case err
          (let ((proc (start-process
                       process-name
                       process-buffer
                       executable
                       "-p"
                       prompt-content)))
            ;; Store the marker in process properties
            (process-put proc 'org-dialog-eng-marker marker)
  	  (process-put proc 'org-dialog-eng-buffer (marker-buffer marker))
  	  (with-current-buffer (marker-buffer marker) (setq buffer-read-only t))
            (set-process-filter proc #'org-dialog-eng--process-filter)
            (set-process-sentinel proc #'org-dialog-eng--process-sentinel)
            (org-dialog-eng--message "Waiting for Claude's response..."))
        (error
         (org-dialog-eng--error "Failed to start Claude CLI: %s" (error-message-string err))
         (kill-buffer process-buffer)))))
#+end_src

* Block Execution

This is the main entry point - called when user presses C-c C-c in a PROMPT block.

It:
1. Finds the containing PROMPT block
2. Builds context from everything before the prompt
3. Formats the full message as: =context + separator + prompt=
4. Sends it to Claude

#+begin_src emacs-lisp
  ;;; Block Execution

  (defun org-dialog-eng--execute-block ()
    "Execute the PROMPT block at point.
  This function is called by org-mode's C-c C-c mechanism.
  Returns t if a PROMPT block was executed, nil otherwise."
    (interactive)
    (let* ((element (org-element-at-point))
           ;; Check if we're IN a block by looking at parent elements
           ;; org-element-lineage walks up the tree to find containing special-blocks
           (block (org-element-lineage element '(special-block) t)))

      ;; Check if we found a PROMPT block in the lineage
      (when (and block
                 (org-dialog-eng--element-is-prompt-block-p block))

        ;; Extract the prompt content
        (let* ((prompt-content (org-dialog-eng--extract-block-content block))
               (block-begin (org-element-property :begin block))
               ;; Build context from start of buffer up to (but not including) this PROMPT block
               (context (org-dialog-eng--build-context block-begin))
               ;; Format the full message with context + emphasized prompt
               (full-message (if (string-empty-p context)
                                 ;; No context, just send the prompt
                                 prompt-content
                               ;; Has context, format with separator
                               (format "%s\n\n---\nPROMPT:\n%s" context prompt-content))))

          (if (or (null prompt-content) (string-empty-p prompt-content))
              (org-dialog-eng--error "PROMPT block is empty")

            ;; Execute Claude with the full message (context + prompt)
            (org-dialog-eng--execute-claude full-message (point-marker))
            t)))))  ; Return t to indicate we handled the C-c C-c
#+end_src

* Minor Mode Definition

#+begin_src emacs-lisp
        ;;; Minor Mode Definition

        ;;;###autoload
  (define-minor-mode org-dialog-eng-mode
    "Minor mode for Claude integration in Org mode.

      This mode adds support for PROMPT blocks that send questions to Claude.

      Key bindings:
        \\[org-ctrl-c-ctrl-c] - Execute prompt block at point (sends to Claude)

      Usage:
        1. Create a #+BEGIN_PROMPT block with your question
        2. Position cursor inside the block
        3. Press C-c C-c
        4. Wait for Claude to respond
        5. Claude's response appears in a #+begin_assistant block below"
    :lighter " AI"
    :group 'org-dialog-eng
    (if org-dialog-eng-mode
        (org-dialog-eng--setup)
      (org-dialog-eng--teardown)))

  (defun org-dialog-eng--setup ()
    "Set up org-dialog-eng-mode in the current buffer."
    ;; Add our ctrl-c-ctrl-c hook
    (add-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block nil t)

    ;; Add font-lock for block highlighting
    (font-lock-add-keywords nil
      			  '(("^\\([ \t]*#\\+begin_prompt\n\\(?:.*\n\\)*?[ \t]*#\\+end_prompt.*$\\)"
      			     (1 'org-dialog-eng-prompt-block t))
      			    ("^\\([ \t]*#\\+begin_assistant\n\\(?:.*\n\\)*?[ \t]*#\\+end_assistant\\)"
      			     (1 'org-dialog-eng-assistant-block t)))
      			  t))


  (defun org-dialog-eng--teardown ()
    "Clean up org-dialog-eng-mode in the current buffer."
    ;; Remove our ctrl-c-ctrl-c hook
    (remove-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block t)
    (font-lock-remove-keywords nil
  			     '(("^\\([ \t]*#\\+begin_prompt\n\\(?:.*\n\\)*?[ \t]*#\\+end_prompt.*$\\)"
  				(1 'org-dialog-eng-prompt-block t))
  			       ("^\\([ \t]*#\\+begin_assistant\n\\(?:.*\n\\)*?[ \t]*#\\+end_assistant\\)"
  				(1 'org-dialog-eng-assistant-block t)))))

  (provide 'org-dialog-eng)

        ;;; org-dialog-eng.el ends here
#+end_src

* Tests
#+begin_prompt
Explain what is the standard or recommended way to create tests for
emacs package such as we are building via this literate programming
document.
#+end_prompt

#+begin_assistant
I'll help you with a concise overview of testing Emacs packages.

For Emacs packages, the standard testing framework is **ERT (Emacs Regression Testing)**, which is built into Emacs. Here are the key practices:

1. **Test File Structure**
   - Create a separate file: `org-dialog-eng-test.el`
   - Prefix test functions with `ert-deftest`
   - Place in a `tests/` or `test/` directory

2. **Basic Test Pattern**
```emacs-lisp
(require 'ert)
(require 'org-dialog-eng)

(ert-deftest org-dialog-eng--test-block-detection ()
  "Test that PROMPT blocks are detected correctly."
  (with-temp-buffer
    (org-mode)
    (insert "#+begin_prompt\nTest\n#+end_prompt")
    (goto-char (point-min))
    (let ((element (org-element-at-point)))
      (should (org-dialog-eng--element-is-prompt-block-p element)))))
```

3. **Running Tests**
   - Interactively: `M-x ert RET t RET`
   - Command line: `emacs -batch -l ert -l org-dialog-eng.el -l org-dialog-eng-test.el -f ert-run-tests-batch-and-exit`

4. **Common Patterns for Your Package**
   - Use `with-temp-buffer` for isolated testing
   - Mock async processes with `cl-letf`
   - Test block detection, content extraction, and context building
   - Use `should`, `should-not`, `should-error` assertions

5. **CI Integration**
   - Common practice: Use GitHub Actions with `purcell/setup-emacs`
   - Can also use `cask` or `makem.sh` for build automation

Would you like me to create a comprehensive test file for `org-dialog-eng-mode`?
#+end_assistant

#+begin_src emacs-lisp :tangle org-dialog-eng-test.el
  (require 'ert)
  (require 'org-dialog-eng)

  (ert-deftest org-dialog-eng--test-block-detection ()
    "Test that PROMPT blocks are detected correctly."
    (with-temp-buffer
      (org-mode)
      (insert "#+begin_prompt\nTest prompt\n#+end_prompt")
      (goto-char (point-min))
      (let ((element (org-element-at-point)))
        (should (org-dialog-eng--element-is-prompt-block-p element)))))

  (ert-deftest org-dialog-eng--test-context-included-with-prompt ()
    "Test that the contents of the file up to the PROMPT block being executed
  are fed into the AI."
    (with-temp-buffer
      (org-mode)
      (insert "* A test header\nSome test content before prompt\n#+begin_prompt\nTest prompt\n#+end_prompt")
      ;; Position cursor in the PROMPT block
      (goto-char (point-min))
      (search-forward "#+begin_prompt")
      (forward-line 1)

      ;; Get the element and its position
      (let* ((element (org-element-at-point))
  	   (block (org-element-lineage element '(special-block) t))
  	   (block-begin (org-element-property :begin block))
  	   (context (org-dialog-eng--build-context block-begin)))

        ;; Verify the context contains expected content
        (should (string-match-p "A test header" context))
        (should (string-match-p "Some test content before prompt" context)))))
#+end_src

#+begin_prompt
I have started writing the org-dialog-eng--test-context-included-with-prompt test
but I don't know how what to check. What do you suggest should be my next step?
#+end_prompt

#+begin_assistant
Good question! For this test, you want to verify that
`org-dialog-eng--build-context` correctly includes content before the
PROMPT block. Here's what you should test:

```emacs-lisp
(ert-deftest org-dialog-eng--test-context-included-with-prompt ()
  "Test that content before PROMPT block is included in context."
  (with-temp-buffer
    (org-mode)
    (insert "* A test header\nSome test content before prompt\n\n#+begin_prompt\nTest prompt\n#+end_prompt")
    ;; Position cursor in the PROMPT block
    (goto-char (point-min))
    (search-forward "#+begin_prompt")
    (forward-line 1)
    
    ;; Get the element and its position
    (let* ((element (org-element-at-point))
           (block (org-element-lineage element '(special-block) t))
           (block-begin (org-element-property :begin block))
           (context (org-dialog-eng--build-context block-begin)))
      
      ;; Verify the context contains expected content
      (should (string-match-p "A test header" context))
      (should (string-match-p "Some test content before prompt" context))
      ;; Verify the prompt itself is NOT in the context
      (should-not (string-match-p "Test prompt" context)))))
```

Key aspects of this test:

1. **Position correctly** - Move cursor into the PROMPT block
2. **Call the internal function** - `org-dialog-eng--build-context` is
   what actually builds context
3. **Verify inclusions** - Check that content before the block appears
4. **Verify exclusions** - Ensure the prompt itself isn't in the
   context (since it's added separately)

You could also add tests for:
- Empty context (PROMPT at start of file)
- Context with code blocks
- Context with multiple sections
- Context with previous ASSISTANT blocks

Would you like me to expand the test suite with these additional cases?
#+end_assistant
