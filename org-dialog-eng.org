#+TITLE: org-dialog-engineering
#+AUTHOR: Pablo Munoz
#+DATE: 2025
#+OPTIONS: toc:3

* Introduction

This document presents =org-dialog-eng-mode=, an Emacs minor mode that transforms Org mode documents into interactive dialogues with Large Language Models (LLMs).

** The Central Idea

The essence of literate programming, as conceived by Donald Knuth, is
to write programs that are primarily literature for human
understanding, with the executable code being a secondary
artifact. This mode extends that philosophy into the realm of human-AI
collaboration: we create documents where the narrative can query an AI
assistant, and the AI's responses become part of the living document
itself.

Imagine writing an Org mode document where you can ask questions,
request code snippets, or seek explanations—and have the answers woven
directly into your document. This is conversational literate
programming: the document grows through dialogue.

** Key Features

- *Executable PROMPT blocks*: Press =C-c C-c= inside a PROMPT block to send it to an LLM
- *Automatic response capture*: Responses appear in ASSISTANT blocks immediately below
- *Full context awareness*: All content before a prompt is sent as context
- *Non-blocking execution*: Emacs remains responsive while the LLM thinks
- *Visual distinction*: PROMPT and ASSISTANT blocks are color-coded for clarity
- *LLM-agnostic design*: Works with any CLI tool that accepts prompts

** How to Read This Document

This is a literate program. The code is presented in an order
optimized for human understanding, not compiler requirements. We use
Org mode's =noweb= syntax to weave the pieces together:

- =<<reference-name>>= marks where code from other sections should be inserted
- =:noweb-ref reference-name= marks code blocks that contribute to a reference
- =:tangle org-dialog-eng.el= marks code blocks that should be extracted to the final file

Read this document linearly to understand the design. The tangled output in =org-dialog-eng.el= will be correctly ordered for Emacs.

* Vision and Design Philosophy

** Why This Mode Exists

Modern software development increasingly involves dialogue with AI
assistants. However, these conversations are typically ephemeral,
happening in separate chat interfaces. When writing literate programs
or technical documents, we lose the context of our document when we
switch to an AI assistant.

=org-dialog-eng-mode= solves this by making the AI assistant a
first-class participant in the document itself. Your questions and the
AI's responses become part of the permanent record, creating a richer
form of literate programming.

** Core Design Principles

1. *Minimal Intrusion*: The mode should feel like a natural extension of Org mode, not a separate system
2. *Transparency*: Users should see exactly what context is sent and what responses are received
3. *Flexibility*: Support any LLM tool that can read from stdin and write to stdout
4. *Asynchronicity*: Never block Emacs while waiting for an LLM response
5. *Persistence*: All interactions are preserved in the document for future reference

** Architectural Decisions

*** Using Special Blocks

Org mode's special blocks (=#+begin_XXX= / =#+end_XXX=) provide a perfect foundation. They:
- Are already parsed by org-element
- Can contain arbitrary content
- Don't conflict with existing Org syntax
- Can be easily styled with font-lock

We define two special block types: =PROMPT= for questions and =ASSISTANT= for responses.

*** Subprocess Architecture

Rather than embedding LLM APIs directly, we spawn subprocesses. This design:
- Keeps the mode LLM-agnostic
- Allows users to configure their preferred tool
- Avoids API key management within Emacs
- Enables non-blocking asynchronous execution
- Works with local models, cloud services, or custom wrappers

*** Context Strategy

We send all document content before the current PROMPT block as context. This means:
- Earlier conversations inform later ones
- Code and notes in the document are automatically available
- The document structure guides the conversation
- No manual context management is required

* Architecture Overview

The mode consists of several cooperating components:

#+begin_example
User presses C-c C-c in PROMPT block
            |
            v
    org-dialog-eng--execute-block (hook)
            |
            v
    Extract prompt content and preceding context
            |
            v
    Format into structured prompt with instructions
            |
            v
    Spawn async subprocess with LLM executable
            |
            v
    Insert placeholder ASSISTANT block immediately
            |
            v
    [User can continue working]
            |
            v
    Subprocess completes
            |
            v
    Sentinel function activates
            |
            v
    Replace placeholder with actual response
            |
            v
    Buffer becomes writable again
#+end_example

This architecture ensures Emacs never blocks, and users receive immediate feedback (the placeholder) followed by the actual response when ready.

* The Tangled Program Structure

The final Emacs Lisp file is assembled from several conceptual
sections. Here's the overall structure:

#+begin_src emacs-lisp :tangle org-dialog-eng.el :noweb yes
;;; org-dialog-eng.el --- LLM integration for Org mode -*- lexical-binding: t; -*-

<<package-header>>

<<dependencies>>

<<custom-group>>

<<faces>>

<<custom-variables>>

<<element-predicates>>

<<content-extraction>>

<<context-collection>>

<<execution>>

<<mode-definition>>

<<provide>>

;;; org-dialog-eng.el ends here
#+end_src

Each =<<section>>= will be defined in the sections that follow.

* Package Header and Metadata

Every well-formed Emacs package begins with proper metadata. This
section defines the package header with copyright information,
requirements, and basic documentation.

#+begin_src emacs-lisp :noweb-ref package-header
;; Copyright (C) 2025 Pablo Munoz

;; Author: Pablo Munoz
;; Version: 0.3.0
;; Package-Requires: ((emacs "27.1") (org "9.0"))
;; Keywords: org, ai, llm, literate-programming
;; URL: https://github.com/pmunoz/org-dialog-eng

;;; Commentary:

;; This package enables interactive dialogues with Large Language Models
;; directly within Org mode documents.  It extends the literate programming
;; paradigm to include AI-assisted document development.
;;
;; Usage:
;;   1. Enable org-dialog-eng-mode in an Org buffer
;;   2. Create a #+begin_prompt block with your question
;;   3. Position cursor inside the block and press C-c C-c
;;   4. An ASSISTANT block with the response appears below
;;
;; The mode sends all document content before the prompt as context,
;; enabling context-aware conversations that reference your notes and code.
;;
;; Configuration:
;;   (require 'org-dialog-eng)
;;   (add-hook 'org-mode-hook #'org-dialog-eng-mode)
;;   (setq org-dialog-eng-executable "claude")  ; or your preferred LLM CLI

;;; Code:
#+end_src

* Dependencies

We rely on Org mode's powerful parsing capabilities to understand
document structure.

#+begin_src emacs-lisp :noweb-ref dependencies
(require 'org)
(require 'org-element)
#+end_src

The =org-element= library provides the abstract syntax tree parsing
that lets us identify special blocks and extract their properties
reliably.

* Visual Design: Faces

Visual distinction helps users immediately recognize PROMPT and
ASSISTANT blocks. We define custom faces with subtle background
colors.

#+begin_src emacs-lisp :noweb-ref faces
(defface org-dialog-eng-prompt-block
  '((t (:background "#2d3a55" :extend t)))
  "Face for PROMPT block content.
The background provides visual distinction for user-authored prompts."
  :group 'org-dialog-eng)

(defface org-dialog-eng-assistant-block
  '((t (:background "#3d2f5b" :extend t)))
  "Face for ASSISTANT block content.
A slightly different hue distinguishes LLM responses from user prompts."
  :group 'org-dialog-eng)
#+end_src

The =:extend t= property ensures the background color extends to the
full window width, creating clear visual boundaries even in wide
windows.

* Customization Group

We define a customization group so users can find all related settings via =M-x customize-group RET org-dialog-eng=.

#+begin_src emacs-lisp :noweb-ref custom-group
(defgroup org-dialog-eng nil
  "LLM integration for Org mode documents."
  :group 'org
  :prefix "org-dialog-eng-")
#+end_src

* Customizable Variables

** The LLM Executable

The most important customization: which LLM tool to use.

#+begin_src emacs-lisp :noweb-ref custom-variables
(defcustom org-dialog-eng-executable "claude"
  "Executable for LLM interaction.
This should be a command-line tool that accepts a prompt via the -p flag
and outputs the response to stdout. Examples: \"claude\", \"copilot\",
or a custom wrapper script."
  :type 'string
  :group 'org-dialog-eng)
#+end_src

*Design Decision*: We use a string rather than a function,
prioritizing simplicity. Users who need complex behavior can write a
shell script wrapper.

* Core Concepts: PROMPT Blocks

** What Is a PROMPT Block?

A PROMPT block is an Org special block containing a question or
request for the LLM:

#+begin_example
#+begin_prompt
Write a Python function to compute the Fibonacci sequence.
#+end_prompt
#+end_example

When executed with =C-c C-c=, the content is sent to the configured
LLM executable.

** Detecting PROMPT Blocks

We need a predicate to identify whether a given org-element is a PROMPT block.

#+begin_src emacs-lisp :noweb-ref element-predicates
(defun org-dialog-eng--element-is-prompt-block-p (element)
  "Return non-nil if ELEMENT is a PROMPT block.
ELEMENT should be an org-element as returned by `org-element-at-point'."
  (and (eq (org-element-type element) 'special-block)
       (string-equal (upcase (org-element-property :type element)) "PROMPT")))
#+end_src

*Implementation Note*: We use =string-equal= with =upcase= because Org mode normalizes block names to uppercase internally, but user input may be mixed case.

** Extracting PROMPT Content

Once we've identified a PROMPT block, we need its textual content (excluding the begin/end markers).

#+begin_src emacs-lisp :noweb-ref content-extraction
(defun org-dialog-eng--extract-block-content (element)
  "Extract the content from special block ELEMENT.
Returns the text between #+begin_XXX and #+end_XXX as a string,
with leading and trailing whitespace trimmed."
  (let* ((begin (org-element-property :contents-begin element))
         (end (org-element-property :contents-end element)))
    (when (and begin end)
      (string-trim (buffer-substring-no-properties begin end)))))
#+end_src

The =:contents-begin= and =:contents-end= properties provided by org-element give us precisely the content boundaries, making this function trivial yet reliable.

* Core Concepts: ASSISTANT Blocks

** What Is an ASSISTANT Block?

An ASSISTANT block contains the LLM's response:

#+begin_example
#+begin_assistant
Here's a Python implementation:

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
#+end_assistant
#+end_example

These blocks are created automatically when a PROMPT is executed.

** Detecting ASSISTANT Blocks

Similar to PROMPT blocks, we need a predicate:

#+begin_src emacs-lisp :noweb-ref element-predicates
(defun org-dialog-eng--element-is-assistant-block-p (element)
  "Return non-nil if ELEMENT is an ASSISTANT block."
  (and (eq (org-element-type element) 'special-block)
       (string-equal (upcase (org-element-property :type element)) "ASSISTANT")))
#+end_src

** Finding the Next ASSISTANT Block

When a PROMPT is executed, we check if an ASSISTANT block immediately follows. If so, we replace it (allowing re-execution of prompts). If not, we insert a new one.

#+begin_src emacs-lisp :noweb-ref content-extraction
(defun org-dialog-eng--find-next-assistant-block (prompt-element)
  "Find the ASSISTANT block immediately following PROMPT-ELEMENT.
Returns the element if found, nil otherwise.
Skips whitespace between the blocks."
  (save-excursion
    (goto-char (org-element-property :end prompt-element))
    ;; Skip any whitespace or blank lines
    (skip-chars-forward " \t\n")
    ;; Check if we're now at an ASSISTANT block
    (let ((next-elem (org-element-at-point)))
      (when (org-dialog-eng--element-is-assistant-block-p next-elem)
        next-elem))))
#+end_src

*Design Decision*: We use =skip-chars-forward= to handle arbitrary
whitespace rather than a fixed number of lines. This makes the system
robust to different user formatting styles.

* Context Collection

** Why Context Matters

LLMs are more useful when they understand what you're working on. By sending all document content before the current PROMPT, we ensure the LLM has full context about:
- Previous questions and answers
- Code examples in the document
- Notes and documentation
- The overall structure of your work

** Extracting Preceding Content

#+begin_src emacs-lisp :noweb-ref context-collection
(defun org-dialog-eng--get-preceding-context ()
  "Extract all buffer content before the current PROMPT block.
Returns a string containing everything from the buffer start
up to (but not including) the current PROMPT block."
  (let* ((element (org-element-at-point))
         (block (org-element-lineage element '(special-block) t))
         (prompt-begin (org-element-property :begin block)))
    (when prompt-begin
      (string-trim
       (buffer-substring-no-properties (point-min) prompt-begin)))))
#+end_src

The =org-element-lineage= function walks up the element tree to find
the containing special-block, even if point is on a line of content
within the block rather than the begin/end markers.

** Formatting the Complete Prompt

We wrap the user's prompt and the context in a structured format with
instructions:

#+begin_src emacs-lisp :noweb-ref context-collection
(defun org-dialog-eng--format-prompt (prompt-content context)
  "Format PROMPT-CONTENT and CONTEXT into a structured prompt.
Returns a string suitable for sending to the LLM executable."
  (format "
<instructions>
You are a helpful assistant helping write an Org mode document in Emacs,
potentially including code (literate programming style). I will provide
a prompt, and you should respond concisely.

If the prompt requests code, provide it in Org syntax (#+begin_src blocks),
not markdown. If it requests modifications, show only the changes needed.

I will also provide context: the content of the Org file we have written
so far, for better-informed responses.

When you see #+begin_prompt ... #+end_prompt delimiters, the content
inside is a prompt I gave you previously.

When you see #+begin_assistant ... #+end_assistant delimiters, the
content inside is a response you gave me previously.

CRITICAL: Since we are editing an Org file together, use Org syntax,
NOT markdown, unless explicitly requested otherwise.
</instructions>

<prompt>
%s
</prompt>

<context>
%s
</context>
" prompt-content context))
#+end_src

*Design Decision*: We use XML-style tags (=<instructions>=, =<prompt>=, =<context>=) rather than natural language markers. This creates clear boundaries that LLMs parse reliably.

* Asynchronous Execution

** The Execution Flow

This is the heart of the mode: executing a PROMPT block and capturing the response.

#+begin_src emacs-lisp :noweb-ref execution
(defun org-dialog-eng--execute-prompt-block ()
  "Execute the PROMPT block at point.
Spawns an async LLM subprocess and inserts the response in an ASSISTANT block.
The buffer becomes read-only during execution to prevent concurrent edits."
  (interactive)
  (let* ((element (org-element-at-point))
         (prompt-content (org-dialog-eng--extract-block-content element))
         (preceding-context (org-dialog-eng--get-preceding-context))
         (formatted-prompt (org-dialog-eng--format-prompt prompt-content preceding-context)))

    (unless prompt-content
      (error "No prompt content found. Ensure cursor is inside a PROMPT block"))

    (let* ((block-end (org-element-property :end element))
           (output-buffer (generate-new-buffer " *llm-output*"))
           (source-buffer (current-buffer)))

      ;; Immediately insert a placeholder ASSISTANT block for feedback
      (save-excursion
        (goto-char block-end)
        (unless (looking-at-p "^[ \t]*$")
          (end-of-line)
          (insert "\n"))
        (insert "\n#+begin_assistant\nLLM is working...\n#+end_assistant\n"))

      ;; Make buffer read-only to prevent concurrent edits
      (setq buffer-read-only t)
      (message "Querying LLM...")

      ;; Spawn the async process
      (make-process
       :name "org-dialog-eng-process"
       :buffer output-buffer
       :command (list org-dialog-eng-executable "-p" formatted-prompt)
       :sentinel
       (lambda (process event)
         (when (string-match-p "finished" event)
           (if (buffer-live-p source-buffer)
               (with-current-buffer source-buffer
                 (let ((response (with-current-buffer output-buffer
                                   (buffer-substring-no-properties
                                    (point-min) (point-max)))))
                   (save-excursion
                     ;; Make buffer temporarily writable
                     (setq buffer-read-only nil)

                     ;; Find and remove any existing ASSISTANT block
                     (let ((next-assistant
                            (org-dialog-eng--find-next-assistant-block element)))
                       (when next-assistant
                         (delete-region
                          (org-element-property :begin next-assistant)
                          (org-element-property :end next-assistant))))

                     ;; Insert the new ASSISTANT block with actual response
                     (goto-char block-end)
                     (unless (looking-at-p "^[ \t]*$")
                       (end-of-line)
                       (insert "\n"))
                     (insert "\n#+begin_assistant\n")
                     (insert (string-trim response))
                     (insert "\n#+end_assistant\n"))

                   ;; Restore read-only status
                   (setq buffer-read-only nil)
                   (message "LLM response inserted")))
             (message "Source buffer no longer exists"))

           ;; Clean up output buffer
           (when (buffer-live-p output-buffer)
             (kill-buffer output-buffer))))

       :stderr (get-buffer-create "*org-dialog-eng-errors*")))))
#+end_src

** Key Implementation Details

*** Placeholder Strategy

We insert a placeholder ASSISTANT block immediately, before the
subprocess starts. This provides instant feedback to the user, showing
that their action was recognized.

*** Read-Only Buffer

While the LLM is thinking, we make the buffer read-only. This prevents
users from editing content that might confuse the position tracking
when we insert the response.

*Alternative Considered*: We could use markers instead of positions,
which would allow concurrent editing. However, this adds complexity
and could lead to confusing insertion points if users edit near the
PROMPT block during execution.

*** Process Sentinel

The sentinel function is called when the subprocess completes. We:
1. Check if the source buffer still exists (user might have killed it)
2. Extract the response from the output buffer
3. Find and delete any placeholder ASSISTANT block
4. Insert the actual response
5. Clean up temporary buffers

*** Error Handling

stderr is redirected to a dedicated buffer (=*org-dialog-eng-errors*=)
so users can debug LLM tool issues without cluttering the main buffer.

* User Interface Integration

** The Execute Hook

Users expect =C-c C-c= in Org mode to "do something appropriate" with
the element at point. We hook into Org's existing mechanism:

#+begin_src emacs-lisp :noweb-ref execution
(defun org-dialog-eng--execute-block ()
  "Hook function for `org-ctrl-c-ctrl-c-hook'.
Executes PROMPT blocks when point is inside one.
Returns non-nil if the block was executed, nil otherwise."
  (let* ((element (org-element-at-point))
         (block (org-element-lineage element '(special-block) t)))
    (when (and block (org-dialog-eng--element-is-prompt-block-p block))
      (org-dialog-eng--execute-prompt-block)
      t)))  ; Return t to stop hook processing
#+end_src

By returning =t= when we handle the block, we prevent other
=org-ctrl-c-ctrl-c-hook= functions from running, avoiding conflicts.

** Font Lock Integration

We register our custom faces with Emacs' font-lock system so blocks
are colored appropriately:

#+begin_src emacs-lisp :noweb-ref mode-definition
(defun org-dialog-eng--fontify-block (limit)
  "Fontify PROMPT and ASSISTANT blocks up to LIMIT.
This is a font-lock matcher function that properly handles multiline blocks."
  (let ((case-fold-search t))
    (when (re-search-forward
           "^[ \t]*#\\+begin_\\(prompt\\|assistant\\)\\>"
           limit t)
      (let* ((block-type (match-string 1))
             (face (if (string-equal (downcase block-type) "prompt")
                       'org-dialog-eng-prompt-block
                     'org-dialog-eng-assistant-block))
             (beg (match-beginning 0))
             (end-re (format "^[ \t]*#\\+end_%s\\>" block-type)))
        (when (re-search-forward end-re limit t)
          (let ((end (match-end 0)))
            (put-text-property beg end 'face face)
            (put-text-property beg end 'font-lock-multiline t)
            (goto-char end)
            t))))))

(defun org-dialog-eng--setup-font-lock ()
  "Add font-lock keywords for PROMPT and ASSISTANT blocks."
  ;; Use a function-based matcher for reliable multiline matching
  (font-lock-add-keywords nil
    '((org-dialog-eng--fontify-block))
    'append)
  ;; Enable multiline font-lock
  (setq-local font-lock-multiline t))

(defun org-dialog-eng--teardown-font-lock ()
  "Remove font-lock keywords for PROMPT and ASSISTANT blocks."
  (font-lock-remove-keywords nil
    '((org-dialog-eng--fontify-block))))
#+end_src

*Implementation Note*: Instead of using complex multiline regexes
(which have limitations in Emacs font-lock), we use a **function-based
font-lock matcher**. The =org-dialog-eng--fontify-block= function
searches for begin markers, finds the corresponding end marker, and
applies the face to the entire region. This approach is more reliable
for multiline blocks and properly sets the =font-lock-multiline=
property to ensure refontification when blocks are edited.

* Mode Definition and Lifecycle

** The Minor Mode

#+begin_src emacs-lisp :noweb-ref mode-definition
;;;###autoload
(define-minor-mode org-dialog-eng-mode
  "Minor mode for LLM integration in Org mode documents.

This mode enables interactive dialogues with Large Language Models
directly within your Org documents. Create PROMPT blocks and execute
them with \\[org-ctrl-c-ctrl-c] to receive ASSISTANT responses.

Key bindings:
  \\[org-ctrl-c-ctrl-c] - Execute PROMPT block at point

Usage:
  1. Create a #+begin_prompt block with your question
  2. Position cursor inside the block
  3. Press \\[org-ctrl-c-ctrl-c]
  4. Wait for the LLM to respond
  5. The response appears in a #+begin_assistant block below

All content before the prompt is sent as context, enabling
context-aware conversations about your document."
  :lighter " AI"
  :group 'org-dialog-eng
  (if org-dialog-eng-mode
      (org-dialog-eng--setup)
    (org-dialog-eng--teardown)))
#+end_src

The =:lighter= appears in the mode line. We use a short " AI" to avoid
cluttering the mode line.

** Setup and Teardown

#+begin_src emacs-lisp :noweb-ref mode-definition
(defun org-dialog-eng--setup ()
  "Set up org-dialog-eng-mode in the current buffer.
Adds hooks and font-lock keywords."
  ;; Hook into C-c C-c
  (add-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block nil t)

  ;; Enable syntax highlighting
  (org-dialog-eng--setup-font-lock)

  ;; Refresh font-lock to apply immediately
  (when (fboundp 'font-lock-flush)
    (font-lock-flush)))

(defun org-dialog-eng--teardown ()
  "Clean up org-dialog-eng-mode in the current buffer.
Removes hooks and font-lock keywords."
  ;; Remove our C-c C-c hook
  (remove-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block t)

  ;; Remove syntax highlighting
  (org-dialog-eng--teardown-font-lock)

  ;; Refresh font-lock
  (when (fboundp 'font-lock-flush)
    (font-lock-flush)))
#+end_src

*Design Decision*: We use buffer-local hooks (the =t= argument to
=add-hook=) so enabling the mode in one buffer doesn't affect others.

** Package Provide

#+begin_src emacs-lisp :noweb-ref provide
(provide 'org-dialog-eng)
#+end_src

* Testing

** Testing Philosophy

Testing an Emacs mode that interacts with external processes presents
unique challenges. We mock the subprocess to avoid dependencies on
actual LLM tools during tests.

** The Placeholder Replacement Test

This test verifies the core interaction: a PROMPT is executed, a placeholder appears, then the actual response replaces it.

#+begin_src emacs-lisp :tangle org-dialog-eng-test.el
(require 'ert)
(require 'org-dialog-eng)

(ert-deftest org-dialog-eng-test-placeholder-replacement ()
  "Test that placeholder ASSISTANT block is replaced with LLM response.

This test mocks the LLM subprocess to verify that:
1. A placeholder ASSISTANT block appears immediately
2. The placeholder is replaced (not duplicated) when response arrives
3. The actual response content is correctly inserted"
  (with-temp-buffer
    (org-mode)
    (org-dialog-eng-mode 1)

    ;; Insert a PROMPT block
    (insert "#+begin_prompt\nTest prompt\n#+end_prompt\n")
    (goto-char (point-min))
    (forward-line 1)  ; Move inside the block

    ;; Mock the LLM executable to return a known response
    (cl-letf (((symbol-function 'make-process)
               (lambda (&rest args)
                 (let ((sentinel (plist-get args :sentinel))
                       (buffer (plist-get args :buffer)))
                   ;; Write mock response to output buffer
                   (with-current-buffer buffer
                     (insert "Test response from LLM"))
                   ;; Create a mock process
                   (let ((proc (make-pipe-process
                                :name "mock-process"
                                :buffer buffer)))
                     ;; Immediately call sentinel with finished status
                     (run-at-time 0.1 nil sentinel proc "finished\n")
                     proc)))))

      ;; Execute the prompt block
      (org-dialog-eng--execute-prompt-block)

      ;; Wait for async completion
      (sleep-for 0.2)

      ;; Verify results
      (goto-char (point-min))
      (should (search-forward "#+begin_assistant" nil t))
      (should-not (search-forward "LLM is working..." nil t))
      (goto-char (point-min))
      (should (search-forward "Test response from LLM" nil t)))))

(ert-deftest org-dialog-eng-test-element-detection ()
  "Test that PROMPT and ASSISTANT blocks are correctly identified."
  (with-temp-buffer
    (org-mode)
    (insert "#+begin_prompt\nTest\n#+end_prompt\n")
    (goto-char (point-min))
    (forward-line 1)
    (let ((element (org-element-at-point)))
      (should (org-dialog-eng--element-is-prompt-block-p
               (org-element-lineage element '(special-block) t))))

    (goto-char (point-max))
    (insert "\n#+begin_assistant\nResponse\n#+end_assistant\n")
    (forward-line -2)
    (let ((element (org-element-at-point)))
      (should (org-dialog-eng--element-is-assistant-block-p
               (org-element-lineage element '(special-block) t))))))

(ert-deftest org-dialog-eng-test-context-extraction ()
  "Test that preceding context is correctly extracted."
  (with-temp-buffer
    (org-mode)
    (insert "* Heading\nSome context here\n\n")
    (insert "#+begin_prompt\nQuestion\n#+end_prompt\n")
    (goto-char (point-min))
    (search-forward "Question")
    (let ((context (org-dialog-eng--get-preceding-context)))
      (should (string-match-p "Heading" context))
      (should (string-match-p "Some context here" context))
      (should-not (string-match-p "Question" context)))))
#+end_src

** Running Tests

Execute tests from the command line:

#+begin_src sh :eval never
emacs --batch -l ert -l org-dialog-eng.el -l org-dialog-eng-test.el \
      -f ert-run-tests-batch-and-exit
#+end_src

Or interactively within Emacs:

#+begin_src emacs-lisp :eval never
M-x load-file RET org-dialog-eng.el RET
M-x load-file RET org-dialog-eng-test.el RET
M-x ert RET t RET
#+end_src

* Usage and Integration Examples

** Basic Setup

Add to your =init.el= or =.emacs=:

#+begin_src emacs-lisp :eval never
(require 'org-dialog-eng)

;; Enable in all Org buffers (optional)
(add-hook 'org-mode-hook #'org-dialog-eng-mode)

;; Or enable manually with: M-x org-dialog-eng-mode
#+end_src

** Integration with Claude CLI

#+begin_src emacs-lisp :eval never
(setq org-dialog-eng-executable "claude")
#+end_src

Ensure the =claude= CLI tool is installed and in your PATH.

** Integration with GitHub Copilot CLI

#+begin_src emacs-lisp :eval never
(setq org-dialog-eng-executable "copilot")
#+end_src

** Custom Wrapper Example

For more control, create a wrapper script:

#+begin_src sh :eval never :tangle no
#!/bin/bash
# my-llm-wrapper: Custom LLM integration
# Handles authentication, logging, or formatting

PROMPT="$1"

# Log prompts for debugging
echo "$PROMPT" >> ~/.llm-prompts.log

# Call your LLM service
curl -s https://api.example.com/llm \
  -H "Authorization: Bearer $API_KEY" \
  -d "{\"prompt\": \"$PROMPT\"}" \
  | jq -r '.response'
#+end_src

Then configure:

#+begin_src emacs-lisp :eval never
(setq org-dialog-eng-executable "~/bin/my-llm-wrapper")
#+end_src

** Example Workflow
I'm building a web scraper in Python that needs to handle rate limiting.

#+begin_prompt
What's the best approach for implementing exponential backoff in a Python web scraper?
#+end_prompt

2. Press =C-c C-c= inside the prompt block

3. The response appears automatically:

#+begin_assistant
For Python web scrapers, I recommend the `tenacity` library for exponential backoff:

#+begin_src python
from tenacity import retry, wait_exponential, stop_after_attempt
import requests

@retry(wait=wait_exponential(multiplier=1, min=4, max=10),
       stop=stop_after_attempt(5))
def fetch_url(url):
    response = requests.get(url)
    response.raise_for_status()
    return response.text
#+end_src

This provides automatic retries with exponential backoff between 4-10 seconds.
#+end_assistant

4. Continue the conversation by adding another prompt that references the previous response.

* Future Directions

** Potential Enhancements

- *Streaming responses*: Display the LLM's output as it generates, rather than waiting for completion
- *Multi-turn refinement*: Add a "refine response" command that sends the ASSISTANT block back for improvement
- *Named conversations*: Support multiple independent conversation threads in one document
- *Export filtering*: Options to exclude PROMPT/ASSISTANT blocks from exports
- *Token counting*: Display estimated token usage before sending prompts
- *History management*: Commands to clear old responses or prune context

** Architectural Extensibility

The subprocess-based design makes many extensions possible without core changes:

- Use different LLMs for different prompts (via block parameters)
- Implement caching layers in wrapper scripts
- Add retry logic or fallback providers
- Integrate with org-babel for executable code responses

** Contributing

This literate program is designed for collaborative improvement. To contribute:

1. Propose changes to the narrative or code
2. Ensure the document remains readable linearly
3. Add tests for new functionality
4. Keep the design philosophy intact: simplicity and transparency

* Conclusion

We have built a mode that extends literate programming into the era of
AI assistance. The implementation is straightforward—under 400 lines
of Emacs Lisp—yet powerful enough to transform how we write technical
documents.

The key insight is that documents can be living conversations, where
human and AI thoughts interleave naturally. As you write, you can ask
questions, request examples, or seek clarifications, and the answers
become part of the permanent record.

This is literate programming for the age of AI: not just explaining
code to humans, but collaborating with AI to create better
explanations, code, and ideas.

* Colophon

This document was written in Org mode using =org-dialog-eng-mode=
itself. Many of the design decisions and code improvements emerged
from conversations embedded in earlier drafts—a form of dogfooding
that validated the core concept.

The noweb-style literate programming approach, pioneered by Norman
Ramsey building on Donald Knuth's WEB system, proves remarkably
well-suited to modern Emacs development. The ability to present code
in human-logical order while tangling it into machine-logical order
remains as valuable today as when Knuth first proposed it in 1984.

#+begin_example
"Let us change our traditional attitude to the construction of programs:
Instead of imagining that our main task is to instruct a computer what to do,
let us concentrate rather on explaining to human beings what we want a
computer to do."
                                                    — Donald Knuth (1984)
#+end_example

To this, we might now add: and let us invite AI assistants to help us
in that explanation.

#+begin_src emacs-lisp :eval never
;; End of org-dialog-eng literate program
#+end_src

