<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-10-23 Thu 23:16 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>org-dialog-engineering</title>
<meta name="author" content="Pablo Munoz" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">org-dialog-engineering</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9977bc9">1. Introduction</a>
<ul>
<li><a href="#org31db749">1.1. Features</a></li>
</ul>
</li>
<li><a href="#orgb4a8db4">2. Package Header</a></li>
<li><a href="#org5f4e6b3">3. Dependencies</a></li>
<li><a href="#org6874078">4. Customization Group</a></li>
<li><a href="#org1460e0c">5. Utility Functions</a></li>
<li><a href="#org5790431">6. Block Detection and Content Extraction</a></li>
<li><a href="#orgcbf329b">7. Context Building</a>
<ul>
<li><a href="#org92cde5a">7.1. Element to Text Conversion</a></li>
<li><a href="#orgbb84679">7.2. Context Builder</a></li>
</ul>
</li>
<li><a href="#orge3c5930">8. Response Insertion</a>
<ul>
<li><a href="#org109cd1f">8.1. ANSI Code Stripping</a></li>
<li><a href="#org7138b09">8.2. Helper Functions for Blank Lines</a></li>
<li><a href="#org2cd5a9e">8.3. Response Block Insertion</a></li>
</ul>
</li>
<li><a href="#orgada0d17">9. Process Execution</a>
<ul>
<li><a href="#orgaa04107">9.1. Process Filter</a></li>
<li><a href="#orgf59fa98">9.2. Process Sentinel</a></li>
<li><a href="#org9ecab12">9.3. Execute Claude</a></li>
</ul>
</li>
<li><a href="#orgc4494aa">10. Block Execution</a></li>
<li><a href="#org3fa304a">11. Minor Mode Definition</a></li>
</ul>
</div>
</div>
<div id="outline-container-org9977bc9" class="outline-2">
<h2 id="org9977bc9"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This is a literate programming implementation of <code>org-dialog-eng-mode</code>, an Emacs minor mode that integrates Claude AI into Org mode documents.
</p>
</div>
<div id="outline-container-org31db749" class="outline-3">
<h3 id="org31db749"><span class="section-number-3">1.1.</span> Features</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Execute PROMPT blocks with <code>C-c C-c</code> to send questions to Claude</li>
<li>Get responses in assistant blocks automatically</li>
<li>Context-aware: sends all content before the prompt as context</li>
<li>Async execution: Emacs stays responsive while Claude thinks</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb4a8db4" class="outline-2">
<h2 id="orgb4a8db4"><span class="section-number-2">2.</span> Package Header</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; org-dialog-eng.el --- Claude integration for Org mode -*- lexical-binding: t; -*-

;; Copyright (C) 2025

;; Author: Pablo Munoz
;; Version: 0.3.0
;; Package-Requires: ((emacs "27.1") (org "9.0"))
;; Keywords: org, ai, claude, prompts
;; URL: https://github.com/pmunoz/org-dialog-eng

;;; Commentary:

;; This package provides integration between Org mode and Claude AI.
;;
;; Usage:
;; 1. Create a #+BEGIN_PROMPT block with your question
;; 2. Position cursor inside the block
;; 3. Press C-c C-c
;; 4. Wait for Claude to respond
;; 5. Claude's response appears in a #+begin_assistant block below
;;
;; The mode sends all content before the prompt as context, enabling
;; natural conversations that reference your notes and code.
;;
;; Setup:
;;   (require 'org-dialog-eng)
;;   (add-hook 'org-mode-hook #'org-dialog-eng-mode)

;;; Code:
</pre>
</div>
</div>
</div>
<div id="outline-container-org5f4e6b3" class="outline-2">
<h2 id="org5f4e6b3"><span class="section-number-2">3.</span> Dependencies</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(require 'org)
(require 'org-element)
</pre>
</div>
</div>
</div>
<div id="outline-container-org6874078" class="outline-2">
<h2 id="org6874078"><span class="section-number-2">4.</span> Customization Group</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Customization

(defgroup org-dialog-eng nil
  "Claude AI integration for Org mode."
  :group 'org
  :prefix "org-dialog-eng-")

(defcustom org-dialog-eng-command "claude"
  "Command to invoke Claude CLI."
  :type 'string
  :group 'org-dialog-eng)

(defcustom org-dialog-eng-executable-path nil
  "Path to Claude CLI executable.
If nil, the command will be searched in PATH."
  :type '(choice (const :tag "Use PATH" nil)
                 (file :tag "Executable path"))
  :group 'org-dialog-eng)
</pre>
</div>
</div>
</div>
<div id="outline-container-org1460e0c" class="outline-2">
<h2 id="org1460e0c"><span class="section-number-2">5.</span> Utility Functions</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Utility Functions

(defun org-dialog-eng--message (format-string &amp;rest args)
  "Display a message for org-dialog-eng with FORMAT-STRING and ARGS."
  (message "[org-dialog-eng] %s" (apply #'format format-string args)))

(defun org-dialog-eng--error (format-string &amp;rest args)
  "Display an error message for org-dialog-eng with FORMAT-STRING and ARGS."
  (error "[org-dialog-eng] %s" (apply #'format format-string args)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5790431" class="outline-2">
<h2 id="org5790431"><span class="section-number-2">6.</span> Block Detection and Content Extraction</h2>
<div class="outline-text-2" id="text-6">
<p>
These functions detect PROMPT and RESPONSE blocks and extract their content.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Block Detection and Content Extraction

(defun org-dialog-eng--element-is-prompt-block-p (element)
  "Return non-nil if ELEMENT is a PROMPT block."
  (and (eq (org-element-type element) 'special-block)
       (string-equal (upcase (org-element-property :type element)) "PROMPT")))

(defun org-dialog-eng--element-is-response-block-p (element)
  "Return non-nil if ELEMENT is an ASSISTANT block."
  (and (eq (org-element-type element) 'special-block)
       (string-equal (upcase (org-element-property :type element)) "ASSISTANT")))

(defun org-dialog-eng--extract-block-content (element)
  "Extract the content from a special block ELEMENT."
  (let* ((begin (org-element-property :contents-begin element))
         (end (org-element-property :contents-end element)))
    (when (and begin end)
      (string-trim (buffer-substring-no-properties begin end)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcbf329b" class="outline-2">
<h2 id="orgcbf329b"><span class="section-number-2">7.</span> Context Building</h2>
<div class="outline-text-2" id="text-7">
<p>
These functions build the conversation context by parsing the org buffer.
</p>
</div>
<div id="outline-container-org92cde5a" class="outline-3">
<h3 id="org92cde5a"><span class="section-number-3">7.1.</span> Element to Text Conversion</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun org-dialog-eng--element-to-text (element)
  "Convert an org ELEMENT to text for context building."
  (let ((type (org-element-type element)))
    (cond
     ;; Source code blocks - format as markdown
     ((eq type 'src-block)
      (let* ((lang (org-element-property :language element))
             (value (org-element-property :value element)))
        (format "```%s\n%s```" (or lang "") (string-trim value))))

     ;; PROMPT blocks - include content
     ((org-dialog-eng--element-is-prompt-block-p element)
      (org-dialog-eng--extract-block-content element))

     ;; ASSISTANT blocks - include content
     ((org-dialog-eng--element-is-response-block-p element)
      (org-dialog-eng--extract-block-content element))

     ;; Other elements - extract text
     (t
      (let* ((begin (org-element-property :begin element))
             (end (org-element-property :end element)))
        (when (and begin end)
          (string-trim
           (buffer-substring-no-properties begin end))))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb84679" class="outline-3">
<h3 id="orgbb84679"><span class="section-number-3">7.2.</span> Context Builder</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Context Building

(defun org-dialog-eng--build-context (end-pos)
  "Build context from buffer start to END-POS.
Returns a string containing all relevant content before the prompt."
  (save-excursion
    (let* ((parse-tree (org-element-parse-buffer))
           (context-parts '()))

      ;; Collect all elements up to end-pos
      (org-element-map parse-tree '(headline paragraph src-block special-block plain-list)
        (lambda (element)
          (let ((elem-begin (org-element-property :begin element)))
            ;; Only process elements before END-POS
            (when (and elem-begin (&lt; elem-begin end-pos))
              (when-let ((text (org-dialog-eng--element-to-text element)))
                (unless (string-empty-p text)
                  (push text context-parts)))))))

      ;; Join all parts with double newlines
      (if context-parts
          (string-join (nreverse context-parts) "\n\n")
        ""))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge3c5930" class="outline-2">
<h2 id="orge3c5930"><span class="section-number-2">8.</span> Response Insertion</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org109cd1f" class="outline-3">
<h3 id="org109cd1f"><span class="section-number-3">8.1.</span> ANSI Code Stripping</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Response Insertion

(defun org-dialog-eng--strip-ansi-codes (text)
  "Remove ANSI escape codes and control characters from TEXT.
Preserves newlines and tabs."
  ;; Remove CSI sequences (ESC[...letter)
  (setq text (replace-regexp-in-string "\033\\[[0-9;?]*[a-zA-Z]" "" text))
  ;; Remove other escape sequences
  (setq text (replace-regexp-in-string "\033[^[]" "" text))
  ;; Clean up control characters but preserve newline (\n = \x0A) and tab (\t = \x09)
  (setq text (replace-regexp-in-string "[\x00-\x08\x0B-\x1F\x7F]" "" text))
  text)
</pre>
</div>
</div>
</div>
<div id="outline-container-org7138b09" class="outline-3">
<h3 id="org7138b09"><span class="section-number-3">8.2.</span> Helper Functions for Blank Lines</h3>
<div class="outline-text-3" id="text-8-2">
<p>
These functions intelligently ensure blank lines exist without adding unnecessary newlines.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun org-dialog-eng--ensure-blank-line-before ()
  "Ensure there is a blank line before point.
Only inserts newlines if needed to create a blank line."
  (let ((chars-before (buffer-substring-no-properties
                       (max (point-min) (- (point) 2))
                       (point))))
    (cond
     ;; Already have blank line (two newlines before point)
     ((string-match-p "\n\n\\'" chars-before) nil)
     ;; Have one newline, need one more
     ((string-match-p "\n\\'" chars-before) (insert "\n"))
     ;; At start of buffer or no newlines, need two
     (t (insert "\n\n")))))

(defun org-dialog-eng--ensure-blank-line-after ()
  "Ensure there is a blank line after point.
Only inserts newlines if needed to create a blank line."
  (let ((chars-after (buffer-substring-no-properties
                      (point)
                      (min (point-max) (+ (point) 2)))))
    (cond
     ;; Already have blank line (two newlines after point)
     ((string-match-p "\\`\n\n" chars-after) nil)
     ;; Have one newline, need one more
     ((string-match-p "\\`\n" chars-after) (insert "\n"))
     ;; At end of buffer or no newlines, need two
     ((= (point) (point-max)) (insert "\n"))
     ;; Content immediately after, need two newlines
     (t (insert "\n\n")))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2cd5a9e" class="outline-3">
<h3 id="org2cd5a9e"><span class="section-number-3">8.3.</span> Response Block Insertion</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun org-dialog-eng--insert-response (response marker)
  "Insert RESPONSE as an ASSISTANT block at MARKER position."
  (when (and response (marker-buffer marker))
    (with-current-buffer (marker-buffer marker)
      (save-excursion
        (goto-char marker)
        ;; Find the containing PROMPT block
        (let* ((element (org-element-at-point))
               (block (org-element-lineage element '(special-block) t)))
          (when block
            ;; Go to the end of the PROMPT block
            (goto-char (org-element-property :end block))
            ;; Ensure blank line before assistant block
            (org-dialog-eng--ensure-blank-line-before)
            (insert "#+begin_assistant\n")
            (insert (string-trim (org-dialog-eng--strip-ansi-codes response)))
            (insert "\n#+end_assistant\n")
            ;; Ensure blank line after assistant block
            (org-dialog-eng--ensure-blank-line-after)
            (org-dialog-eng--message "Response inserted successfully")))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgada0d17" class="outline-2">
<h2 id="orgada0d17"><span class="section-number-2">9.</span> Process Execution</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgaa04107" class="outline-3">
<h3 id="orgaa04107"><span class="section-number-3">9.1.</span> Process Filter</h3>
<div class="outline-text-3" id="text-9-1">
<p>
The process filter receives output from Claude as it arrives and accumulates
it in the process buffer.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">  ;;; Process Execution

  (defun org-dialog-eng--process-filter (process output)
    "Process filter for Claude CLI PROCESS OUTPUT.
Accumulates output in process buffer."
    (when (buffer-live-p (process-buffer process))
      (with-current-buffer (process-buffer process)
        (goto-char (point-max))
        (insert output))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf59fa98" class="outline-3">
<h3 id="orgf59fa98"><span class="section-number-3">9.2.</span> Process Sentinel</h3>
<div class="outline-text-3" id="text-9-2">
<p>
The sentinel handles process completion:
</p>
<ol class="org-ol">
<li>On success: inserts the response into the org buffer</li>
<li>On error: shows error message</li>
</ol>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun org-dialog-eng--process-sentinel (process event)
  "Process sentinel for Claude CLI PROCESS.
EVENT describes what happened to the process."
  (let ((status (process-status process))
        (marker (process-get process 'org-dialog-eng-marker)))
    (cond
     ((eq status 'exit)
      (let ((exit-code (process-exit-status process)))
        (if (= exit-code 0)
            ;; Success - insert the response
            (when (buffer-live-p (process-buffer process))
              (let ((response (with-current-buffer (process-buffer process)
                               (buffer-string))))
                (org-dialog-eng--insert-response response marker)
                (kill-buffer (process-buffer process))))
          ;; Error - show message
          (org-dialog-eng--error "Claude CLI exited with code %d: %s"
                               exit-code
                               (if (buffer-live-p (process-buffer process))
                                   (with-current-buffer (process-buffer process)
                                     (buffer-string))
                                 "")))))

     ((eq status 'signal)
      (org-dialog-eng--error "Claude CLI process killed: %s" event))

     (t
      (org-dialog-eng--message "Claude CLI process status: %s" event)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9ecab12" class="outline-3">
<h3 id="org9ecab12"><span class="section-number-3">9.3.</span> Execute Claude</h3>
<div class="outline-text-3" id="text-9-3">
<p>
This function starts the Claude process:
</p>
<ol class="org-ol">
<li>Starts the async process with the <code>-p</code> flag to pass the prompt</li>
<li>Wires up the filter and sentinel</li>
<li>Waits for Claude to respond</li>
</ol>

<p>
The process runs asynchronously, so Emacs remains responsive while Claude generates
the response.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun org-dialog-eng--execute-claude (prompt-content marker)
  "Execute Claude with PROMPT-CONTENT asynchronously.
Insert response at MARKER when complete."
  (let* ((executable (or org-dialog-eng-executable-path org-dialog-eng-command))
         (process-buffer (generate-new-buffer " *org-dialog-eng-output*"))
         (process-name "org-dialog-eng"))

    ;; Start the async process: claude -p "prompt content"
    (org-dialog-eng--message "Sending prompt to Claude...")
    (condition-case err
        (let ((proc (start-process
                     process-name
                     process-buffer
                     executable
                     "-p"
                     prompt-content)))
          ;; Store the marker in process properties
          (process-put proc 'org-dialog-eng-marker marker)
          (set-process-filter proc #'org-dialog-eng--process-filter)
          (set-process-sentinel proc #'org-dialog-eng--process-sentinel)
          (org-dialog-eng--message "Waiting for Claude's response..."))
      (error
       (org-dialog-eng--error "Failed to start Claude CLI: %s" (error-message-string err))
       (kill-buffer process-buffer)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc4494aa" class="outline-2">
<h2 id="orgc4494aa"><span class="section-number-2">10.</span> Block Execution</h2>
<div class="outline-text-2" id="text-10">
<p>
This is the main entry point - called when user presses C-c C-c in a PROMPT block.
</p>

<p>
It:
</p>
<ol class="org-ol">
<li>Finds the containing PROMPT block</li>
<li>Builds context from everything before the prompt</li>
<li>Formats the full message as: <code>context + separator + prompt</code></li>
<li>Sends it to Claude</li>
</ol>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Block Execution

(defun org-dialog-eng--execute-block ()
  "Execute the PROMPT block at point.
This function is called by org-mode's C-c C-c mechanism.
Returns t if a PROMPT block was executed, nil otherwise."
  (interactive)
  (let* ((element (org-element-at-point))
         ;; Check if we're IN a block by looking at parent elements
         ;; org-element-lineage walks up the tree to find containing special-blocks
         (block (org-element-lineage element '(special-block) t)))

    ;; Check if we found a PROMPT block in the lineage
    (when (and block
               (org-dialog-eng--element-is-prompt-block-p block))

      ;; Extract the prompt content
      (let* ((prompt-content (org-dialog-eng--extract-block-content block))
             (block-begin (org-element-property :begin block))
             ;; Build context from start of buffer up to (but not including) this PROMPT block
             (context (org-dialog-eng--build-context block-begin))
             ;; Format the full message with context + emphasized prompt
             (full-message (if (string-empty-p context)
                               ;; No context, just send the prompt
                               prompt-content
                             ;; Has context, format with separator
                             (format "%s\n\n---\nPROMPT:\n%s" context prompt-content))))

        (if (or (null prompt-content) (string-empty-p prompt-content))
            (org-dialog-eng--error "PROMPT block is empty")

          ;; Execute Claude with the full message (context + prompt)
          (org-dialog-eng--execute-claude full-message (point-marker))
          t)))))  ; Return t to indicate we handled the C-c C-c
</pre>
</div>
</div>
</div>
<div id="outline-container-org3fa304a" class="outline-2">
<h2 id="org3fa304a"><span class="section-number-2">11.</span> Minor Mode Definition</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">
<pre class="src src-emacs-lisp">  ;;; Minor Mode Definition

  ;;;###autoload
  (define-minor-mode org-dialog-eng-mode
    "Minor mode for Claude integration in Org mode.

This mode adds support for PROMPT blocks that send questions to Claude.

Key bindings:
  \\[org-ctrl-c-ctrl-c] - Execute prompt block at point (sends to Claude)

Usage:
  1. Create a #+BEGIN_PROMPT block with your question
  2. Position cursor inside the block
  3. Press C-c C-c
  4. Wait for Claude to respond
  5. Claude's response appears in a #+begin_assistant block below"
    :lighter " AI"
    :group 'org-dialog-eng
    (if org-dialog-eng-mode
        (org-dialog-eng--setup)
      (org-dialog-eng--teardown)))

  (defun org-dialog-eng--setup ()
    "Set up org-dialog-eng-mode in the current buffer."
    ;; Add our ctrl-c-ctrl-c hook
    (add-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block nil t))

  (defun org-dialog-eng--teardown ()
    "Clean up org-dialog-eng-mode in the current buffer."
    ;; Remove our ctrl-c-ctrl-c hook
    (remove-hook 'org-ctrl-c-ctrl-c-hook #'org-dialog-eng--execute-block t))

  (provide 'org-dialog-eng)

  ;;; org-dialog-eng.el ends here
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Pablo Munoz</p>
<p class="date">Created: 2025-10-23 Thu 23:16</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
